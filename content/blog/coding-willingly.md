+++
title = "Can I code willingly everytime?"
date = 2026-01-27
description = "Simple, [un]tested ways to slowly overcome randomly-induced procrastination, and my thoughts on applying them."
authors = ["hitblast"]

[taxonomies]
tags = ["thoughts"]
+++

### preface

I've always wanted to code a lot - yes, that's the one thing that I quite literally *always* wanted to achieve with myself. Here "a lot" is metaphorical - I can't *always* code to achieve this goal. But I can, however, densely pack my sessions to include stuff which I *do like* to work on that eventually helps me to *actually code more*.

Now, I know, this intro might've been a little bit wonky and a little bit improperly placed too... but, from what I've experienced for the past few years regarding this, I can safely say that my attention span is wonkier than a plane with broken ailerons pitching up and down violently...

I'll give some context to ease the wonky bit for you.

I've always wanted to have a consistent mind - whether it be for achieving a particular goal or for just living my own personal life, this is the one thing that I've always wanted, and somehow, always failed to achieve. I get a sudden burst of ideas which lose their motion as soon as they arrive. Ironically it turns out, modern-day entertainment has also induced its bad effects on me aye, even if a tiny amount. Now as that had started to take place, it didn't take much for me to notice it. Post-dengue brain fog has also had its issues with me, though they're mostly wearing out now. I was extremely poor at concentrating in studies for a while, and seems like that part of me is recovering.

Programming, however, is a different story.

I have frequent ideas on various topics. Some are good, some are problematic. By "problematic", I define two things here:

- *The idea is complex to solve at the moment.* As I've covered a few years (7 years, according to GitHub) of programming lately, this is much less of an issue nowadays, but yeah, software is all about learning consistently and you never learn consistently.
- *The urge to complete the idea is scarce.* I have a project which I've been working on and whcih is specific to macOS, but I constantly need to replenish my motivation. This is a seemingly bad thing which I've identified.

I need to fix these two. And, what is my plan exactly?

### active force method

I kind of want to push myself into it, since I know I like it as a passion and I really love having a ton of projects covering a ton of different agendas - the only thing that keeps me from it is the lack of urge to slowly cover all of them, or at least, most.

I want to have a sort of "logger" for my shell which will count the days from a starting point and allow me to write down my programming achievements for that day. It effectively turns the method into a "100 days of code"-sorta challenge. However, this method, by definition, needs a project of its own.

*It has been recursion all along.*

Regardless, forcing is not quite the solution for a lot of us, and might as well not be for me, so I want to look at a second and more methodological way of solving this.

### passive force method

*(while writing this I had the daydreams of an Alcubierre Warp Drive from ["GO INCREDIBLY FAST"](https://www.youtube.com/watch?v=RiJFo-kaJBQ) so excuse my tiny bit of excitement that I pushed into this part of the entry)*

Forcing is always a bad thing, in my opinion. The same applies to computer science graduates who are only doing the whole thing to feed their families and not out of sheer passion for engineering. The common thing? You get a diminishing return. The twist is that the returns graphically represent a hyperbolically declining line and your brain is on fire.

This way focuses on tinkering with the values of your interest. I have always found this trick pretty neat, and the way that it works is, you start linking your projects to initiate it.

I usually work with a lot of CLI/tools written in a particular language. Now I really hate duplicated code (although it's good for practice) but for those particular CLIs, I had found that I was using a shared framework. I decided to create a template repository which stays on both cloud and on my local machine. It only gives me some boilerplate to work with, but that's one extra repository that I can feel good about having on my profile.

So, initially it might seem like this - **"Buy one get one free."** Before the admission season, this helped me get to a point where I actually felt good about programming and always looked forward to it. So, I know this works for me.

The other way it works is that, you start doing smaller modifications *across your domains of interest* while you focus on a single project. I usually go through this one by working on several other components on my workflow (even something extremely silly as configuring one particular tool to optimally perform according to my needs), while I'm working on a new tool to publish. This helps me keep my esteem high and embrace the good things that programming delivers to a developer.

A possible final way, and its quite untested by me, could be something as simple as **reading books**. I kind of want to test this out by buying some language-specific books later on once I get back to studying for the next phase of my admission. This, however, needs *your initial interest* in programming to work. I used to do this a lot during 2021-2022 where I would read about a particular concept in a language, say, decorators in Python, and then I went straight to thinking about "how I can implement decorators in this bot I'm writing". This could double as a learning pipeline alongside your procrastination killer.

---

These were my two cents on a topic I'm still aiming to solve, and hopefully by the time I've solved this attention crisis of mine, I'll have a definitive answer for people who still struggle with this and are very much learning the same way as I do. Till then, adios!
